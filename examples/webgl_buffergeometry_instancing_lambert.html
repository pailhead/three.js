<!DOCTYPE html>
<html lang="en">
<head>
	<title>three.js webgl - instancing - lambert shader</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body {
			color: #ffffff;
			font-family: Monospace;
			font-size: 13px;
			text-align: center;
			font-weight: bold;
			background-color: #000000;
			margin: 0px;
			overflow: hidden;
		}

		#info {
			position: absolute;
			top: 0px;
			width: 100%;
			padding: 5px;
		}

		a {
			color: #ffffff;
		}

		#notSupported {
			width: 50%;
			margin: auto;
			border: 2px red solid;
			margin-top: 20px;
			padding: 10px;
		}
	</style>
</head>
<body>

	<div id="container"></div>
	<div id="info">
		<a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> - instancing - lambert shader
		<div id="notSupported" style="display:none">Sorry your graphics card + browser does not support hardware instancing</div>
	</div>

	<script src="../build/three.js"></script>
	<script src="js/Detector.js"></script>
	<script src="js/libs/stats.min.js"></script>

	<script src="js/controls/OrbitControls.js"></script>
	<script src="js/CurveExtras.js"></script>


	<script>
		
		if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

		var depthIncludes = {
			begin_vertex: 
			`
			${THREE.ShaderChunk.begin_vertex}
			// instanced
			#ifdef INSTANCED

				transformed *= instanceScale;
				transformed = transformed + instanceOffset;

			#endif
			`,
			uv_pars_vertex: //in lieu of hooks this is where globals can safely be included in almost all materials
			`
			#define INSTANCED
			${THREE.ShaderChunk.uv_pars_vertex}
			#ifdef INSTANCED

				attribute vec3 instanceOffset;
				attribute float instanceScale;

			#endif
			`
		}

		//no need for customShaderLib dependency can be declared here
		var customDepthMaterial = new THREE.MeshDepthMaterial({ depthPacking: THREE.RGBADepthPacking })
		customDepthMaterial.shaderIncludes = depthIncludes

		var lambertIncludes = {
			uv_pars_vertex: //in lieu of hooks this is where globals can safely be included in almost all materials
			`
			#define INSTANCED
			${THREE.ShaderChunk.uv_pars_vertex}

			#ifdef INSTANCED
				attribute vec3 instanceOffset;
				attribute vec3 instanceColor;
				attribute float instanceScale;
			#endif
			
			`,
			color_vertex: 
			`
			${THREE.ShaderChunk.color_vertex}
			// vertex colors instanced
			#ifdef INSTANCED
				#ifdef USE_COLOR
					vColor.xyz = vec3(1.);
				#endif
			#endif
			`,
			begin_vertex: 
			`
			${THREE.ShaderChunk.begin_vertex}
			// position instanced
			#ifdef INSTANCED
				transformed *= instanceScale;
				transformed = transformed + instanceOffset;
			#endif
			`,
		}

		//much more declarative plus a familiar interface
		var material = new THREE.MeshLambertMaterial({
			vertexColors: THREE.VertexColors,
			fog: true,
			color: new THREE.Color(0xffb54a),
			reflectivity: 1
		})
		material.shaderIncludes = lambertIncludes //this could also be provided in params but best encapsulated in sub class

		var mesh, renderer, scene, camera, controls;
		var stats;

		init();
		animate();

		function init() {

			renderer = new THREE.WebGLRenderer( { antialias: true } );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.shadowMap.enabled = true;
			document.body.appendChild( renderer.domElement );

			renderer.gammaOutput = true;

			scene = new THREE.Scene();

			scene.fog = new THREE.FogExp2( 0x000000, 0.004 );
			renderer.setClearColor( scene.fog.color, 1 );

			camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 1000 );
			camera.position.set( 80, 40, 80 );

			scene.add( camera );

			controls = new THREE.OrbitControls( camera, renderer.domElement );
			controls.enableZoom = false;
			controls.maxPolarAngle = Math.PI / 2;

			scene.add( new THREE.AmbientLight( 0xffffff, 0.7 ) );

			var light = new THREE.DirectionalLight( 0xffffff, 0.4 );
			light.position.set( 50, 40, 0 );

			light.castShadow = true;
			light.shadow.camera.left = - 40;
			light.shadow.camera.right = 40;
			light.shadow.camera.top = 40;
			light.shadow.camera.bottom = - 40;
			light.shadow.camera.near = 10;
			light.shadow.camera.far = 180;

			light.shadow.bias = - 0.001;
			light.shadow.mapSize.width = 512;
			light.shadow.mapSize.height = 512;

			scene.add( light );

			// light shadow camera helper
			//light.shadowCameraHelper = new THREE.CameraHelper( light.shadow.camera );
			//scene.add( light.shadowCameraHelper );


			// instanced buffer geometry

			var geometry = new THREE.InstancedBufferGeometry();
			geometry.copy( new THREE.TorusBufferGeometry( 2, 0.5, 8, 128 ) );

			const INSTANCES = 256;

			var knot = new THREE.Curves.TorusKnot( 10 );
			var positions = knot.getSpacedPoints( INSTANCES );

			var offsets = new Float32Array( INSTANCES * 3 ); // xyz
			var colors = new Float32Array( INSTANCES * 3 ); // rgb
			var scales = new Float32Array( INSTANCES * 1 ); // s

			var color = new THREE.Color();

			for ( var i = 0, l = INSTANCES; i < l; i ++ ) {

				var index = 3 * i;

				// per-instance position offset
				offsets[ index ] = positions[ i ].x;
				offsets[ index + 1 ] = positions[ i ].y;
				offsets[ index + 2 ] = positions[ i ].z;

				// per-instance color tint - optional
				colors[ index ] = 1;
				colors[ index + 1 ] = 1;
				colors[ index + 2 ] = 1;

				// per-instance scale variation
				scales[ i ] = 1 + 0.5 * Math.sin( 32 * Math.PI * i / INSTANCES );

			}

			geometry.addAttribute( 'instanceOffset', new THREE.InstancedBufferAttribute( offsets, 3 ) );
			geometry.addAttribute( 'instanceColor', new THREE.InstancedBufferAttribute( colors, 3 ) );
			geometry.addAttribute( 'instanceScale', new THREE.InstancedBufferAttribute( scales, 1 ) );

			// material

			var envMap = new THREE.TextureLoader().load( `textures/metal.jpg`, function ( texture ) {

				texture.mapping = THREE.SphericalReflectionMapping;
				material.needsUpdate = true
			} );

			material.envMap = envMap
			material.needsUpdate = true

			// defines - Since we are reusing the ShaderChunks, we must specify the required defines.
			// The renderer does not set these defines for ShaderMaterial

			mesh = new THREE.Mesh( geometry, material );
			mesh.scale.set( 1, 1, 2 );
			mesh.castShadow = true;
			mesh.receiveShadow = true;
			mesh.customDepthMaterial = customDepthMaterial;
			mesh.frustumCulled = false;

			scene.add( mesh );

			//

			var ground = new THREE.Mesh(
				new THREE.PlaneBufferGeometry( 800, 800 ).rotateX( - Math.PI / 2 ),
				new THREE.MeshPhongMaterial( { color: 0x888888 } )
			);
			ground.position.set( 0, - 40, 0 );
			ground.receiveShadow = true;

			scene.add( ground );

			//

			stats = new Stats();
			document.body.appendChild( stats.dom );

			//

			window.addEventListener( 'resize', onWindowResize, false );

		}

		function onWindowResize( event ) {

			renderer.setSize( window.innerWidth, window.innerHeight );

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

		}

		function animate() {

			requestAnimationFrame( animate );

			mesh.rotation.y += 0.005;

			stats.update();

			renderer.render( scene, camera );

		}


	</script>

</body>

</html>
