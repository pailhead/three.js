<!DOCTYPE html>
<html lang="en">
<head>
	<title>three.js webgl - instancing - lambert shader</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body {
			color: #ffffff;
			font-family: Monospace;
			font-size: 13px;
			text-align: center;
			font-weight: bold;
			background-color: #000000;
			margin: 0px;
			overflow: hidden;
		}

		#info {
			position: absolute;
			top: 0px;
			width: 100%;
			padding: 5px;
		}

		a {
			color: #ffffff;
		}

		#notSupported {
			width: 50%;
			margin: auto;
			border: 2px red solid;
			margin-top: 20px;
			padding: 10px;
		}
	</style>
</head>
<body>

	<div id="container"></div>
	<div id="info">
		<a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> - instancing - lambert shader
		<div id="notSupported" style="display:none">Sorry your graphics card + browser does not support hardware instancing</div>
	</div>

	<script src="../build/three.js"></script>
	<script src="js/Detector.js"></script>
	<script src="js/libs/stats.min.js"></script>

	<script src="js/controls/OrbitControls.js"></script>
	<script src="js/CurveExtras.js"></script>
	<script src="js/libs/dat.gui.min.js"></script>


	<script>
		/*eslint-disable*/
		if ( ! Detector.webgl ) Detector.addGetWebGLMessage();


		var renderer, scene, camera, controls, materials, mesh;
		var stats, gui, guiProps;
		var guiData = { material: 'MeshStandard' }

		init();
		animate();

		var guis = []

		function onMaterialChange( value ) {
				
			while(guis.length){
				guiProps.remove(guis.pop())
			}
			mesh.material = materials[value]

			var u = function(){
				for (var i = mesh.material.userData.extraProps.length - 1; i >= 0; i--) {
					var n = mesh.material.userData.extraProps[i]
					guis.push( guiProps.add(mesh.material[`${n}Offset`],'x', 0, 5).name(`${n}Offset U`) )
					guis.push( guiProps.add(mesh.material[`${n}Offset`],'y', 0, 5).name(`${n}Offset V`) )
					guis.push( guiProps.add(mesh.material[`${n}Scale`],'x', 0, 5).name(`${n}Scale U`) )
					guis.push( guiProps.add(mesh.material[`${n}Scale`],'y', 0, 5).name(`${n}Scale V`) )
				}
			}

			if(!mesh.material.userData.extraProps){
				setTimeout(u,100)
			} else {
				u()
			}

		} 



		function initGUI(){

			gui = new dat.GUI()

			gui.add( 

				guiData, 
				'material', 
				[
					'MeshPhong',
					'MeshStandard',
				] 

			).onChange(onMaterialChange)

			guiProps = gui.addFolder('texture controls')
			guiProps.open()
			
			onMaterialChange(guiData.material)

		}


		function init() {

			//share with other extended examples?
			// -----------------------------------------------------------------------------
			
			renderer = new THREE.WebGLRenderer( { antialias: true } );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.shadowMap.enabled = true;
			document.body.appendChild( renderer.domElement );

			renderer.gammaOutput = true;

			scene = new THREE.Scene();

			scene.fog = new THREE.FogExp2( 0x000000, 0.004 );
			renderer.setClearColor( scene.fog.color, 1 );

			camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 1000 );
			camera.position.set( 80, 40, 80 );

			scene.add( camera );

			controls = new THREE.OrbitControls( camera, renderer.domElement );
			controls.enableZoom = false;
			controls.maxPolarAngle = Math.PI / 2;

			scene.add( new THREE.AmbientLight( 0xffffff, 0.7 ) );

			var light = new THREE.DirectionalLight( 0xffffff, 0.4 );
			light.position.set( 50, 40, 0 );

			light.castShadow = true;
			light.shadow.camera.left = - 40;
			light.shadow.camera.right = 40;
			light.shadow.camera.top = 40;
			light.shadow.camera.bottom = - 40;
			light.shadow.camera.near = 10;
			light.shadow.camera.far = 180;

			light.shadow.bias = - 0.001;
			light.shadow.mapSize.width = 512;
			light.shadow.mapSize.height = 512;

			scene.add( light );

			var ground = new THREE.Mesh(
				new THREE.PlaneBufferGeometry( 800, 800 ).rotateX( - Math.PI / 2 ),
				new THREE.MeshPhongMaterial( { color: 0x888888 } )
			);
			ground.position.set( 0, - 40, 0 );
			ground.receiveShadow = true;

			scene.add( ground );

			stats = new Stats();
			document.body.appendChild( stats.dom );

			window.addEventListener( 'resize', onWindowResize, false );

			// -----------------------------------------------------------------------------
			

			// example

			var texture = new THREE.TextureLoader().load( `textures/roughness_map.jpg` )
			texture.wrapS = texture.wrapT = THREE.RepeatWrapping
			//an environment map
			var envMap = new THREE.TextureLoader().load( `textures/metal.jpg`, function ( texture ) {

				texture.mapping = THREE.SphericalReflectionMapping;
				texture.encoding = THREE.sRGBEncoding;

				mesh = new THREE.Mesh( new THREE.SphereGeometry(10,32,16), materials[guiData.material] )

				scene.add( mesh );

			} );

			//create an instance of various types of materials
			materials = {

				MeshPhong: new THREE.MeshPhongMaterial({ 
					color: 0xffb54a,
					envMap: envMap,
					fog: true,
					transparent: true
				}),

				MeshStandard: new THREE.MeshStandardMaterial({
					color: 0xffb54a,
					envMap: envMap,
					metalness: 1,
					roughness: 1,
					fog: true,
					transparent: true
				}),

			}

			var validMaps = {
				'map': true,
				'roughnessMap': true,
				'metalnessMap': true,
				// 'normalMap': true,
				'alphaMap': true,
				'specularMap': true
			}

			/**
			 * HACK:
			 * this is actually "onBeforeParse" along with "onBeforeCompile"
			 * for this effect to work, it would actually be beneficial to do it
			 * in "onAfterParse" but before compilation, 
			 * it is safe to pre parse the includes which we can do like so:
			 */
			var pattern = /#include <(.*)>/gm

			function parseIncludes( string ){
				function replace( match , include ){
					var replace = THREE.ShaderChunk[ include ]
					return parseIncludes( replace )
				}
				return string.replace( pattern, replace )
			}

			/**
			 * Solution:
			 *
			 * we can look for where vUv is used and extend those maps with their own
			 * transform uniform, for this simple example we are going to use a vec4 to store
			 * a per channel offset and scale
			 */
			
			//look for maps that are mapped with vUv
			var mapRegex = /texture2D\( (.*Map|map), vUv \)/gm

 			
			var onBeforeCompile = function ( shader ) {

				var prependUniforms = ''

				var level = 1

				const extraUniforms = {}
				this.userData.extraUniforms = extraUniforms

				const extraProps = []
				this.userData.extraProps = extraProps

				var _this = this

				function replaceMaps( string ){

					function replace( match, mapName ) {

						if(!validMaps[mapName]) return match


						var uniformNameScale = `u_${mapName}Scale`
						var uniformNameOffset = `u_${mapName}Offset`

						var uniformScale = { value: new THREE.Vector2(level,level) }
						var uniformOffset = { value: new THREE.Vector2(level*0.25,level*0.25) }

						shader.uniforms[uniformNameScale] = uniformScale
						extraUniforms[uniformNameScale ] = uniformScale 
						shader.uniforms[uniformNameOffset] = uniformOffset
						extraUniforms[uniformNameOffset ] = uniformOffset 

						level++
						prependUniforms += `uniform vec2 ${uniformNameScale};\n`
						prependUniforms += `uniform vec2 ${uniformNameOffset};\n`

						extraProps.push(mapName)
						var foo = {
							[`${mapName}Scale`]: {
								get: function(){ return extraUniforms[uniformNameScale].value },
								set: function(val){ extraUniforms[uniformNameScale].value.copy(val) }
							},
							[`${mapName}Offset`]: {
								get: function(){ return extraUniforms[uniformNameOffset].value },
								set: function(val){ extraUniforms[uniformNameOffset].value.copy(val) }
							}
						}
						Object.defineProperties(
							_this,
							foo
						)

						var replace = `texture2D( ${mapName}, vUv * ${uniformNameScale} + ${uniformNameOffset} )`
						return replaceMaps( replace ) 
					}

					return string.replace( mapRegex, replace )
				}

				shader.fragmentShader = parseIncludes(shader.fragmentShader) //"unroll" the entire shader
				shader.fragmentShader = replaceMaps(shader.fragmentShader) //patch in the mapping stuff

				shader.fragmentShader = prependUniforms + shader.fragmentShader

				//init here so it can take params
				if(!gui) initGUI()
			}

			//extend these materials
			for ( materialName in materials ) {

				var material = materials[materialName]

				for ( var map in validMaps ){
					if(material[map] === null) {
						material[map] = texture
					}
				}

				material.onBeforeCompile = onBeforeCompile.bind( material )

			}

		}

		function onWindowResize( event ) {

			renderer.setSize( window.innerWidth, window.innerHeight );

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

		}

		function animate() {

			requestAnimationFrame( animate );

			if(mesh) mesh.rotation.y += 0.005

			stats.update();

			renderer.render( scene, camera );

		}


	</script>

</body>

</html>
